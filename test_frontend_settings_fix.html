<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‰ç«¯è®¾ç½®åŠŸèƒ½æµ‹è¯•</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .test-result { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 3px; }
        button { padding: 10px 15px; margin: 5px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .success { color: green; }
        .error { color: red; }
        .info { color: blue; }
        input, select { padding: 8px; margin: 5px; border: 1px solid #ddd; border-radius: 3px; }
        .form-group { margin: 10px 0; }
        label { display: inline-block; width: 120px; font-weight: bold; }
    </style>
</head>
<body>
    <h1>ğŸ§ª å‰ç«¯è®¾ç½®åŠŸèƒ½æµ‹è¯•</h1>
    
    <div class="test-section">
        <h2>1. æ¨¡æ‹Ÿè®¾ç½®è¡¨å•</h2>
        <div class="form-group">
            <label>ç³»ç»Ÿåç§°:</label>
            <input type="text" id="systemName" value="RAG Knowledge QA System (Dev)">
        </div>
        <div class="form-group">
            <label>LLMæä¾›å•†:</label>
            <select id="llmProvider">
                <option value="siliconflow">SiliconFlow</option>
                <option value="openai">OpenAI</option>
                <option value="deepseek">DeepSeek</option>
            </select>
        </div>
        <div class="form-group">
            <label>LLMæ¨¡å‹:</label>
            <input type="text" id="llmModel" value="Qwen/Qwen2-7B-Instruct">
        </div>
        <div class="form-group">
            <label>æ¸©åº¦:</label>
            <input type="number" id="llmTemperature" value="0.7" step="0.1" min="0" max="2">
        </div>
        <div class="form-group">
            <label>æœ€å¤§ä»¤ç‰Œ:</label>
            <input type="number" id="llmMaxTokens" value="2000" min="100" max="4000">
        </div>
        <div class="form-group">
            <label>åµŒå…¥æä¾›å•†:</label>
            <select id="embeddingProvider">
                <option value="siliconflow">SiliconFlow</option>
                <option value="openai">OpenAI</option>
            </select>
        </div>
        <div class="form-group">
            <label>åµŒå…¥æ¨¡å‹:</label>
            <input type="text" id="embeddingModel" value="BAAI/bge-large-zh-v1.5">
        </div>
        <div class="form-group">
            <label>å—å¤§å°:</label>
            <input type="number" id="chunkSize" value="400" min="100" max="2000">
        </div>
        <div class="form-group">
            <label>å—é‡å :</label>
            <input type="number" id="chunkOverlap" value="50" min="0" max="500">
        </div>
        
        <button onclick="testSettingsSave()">æµ‹è¯•è®¾ç½®ä¿å­˜</button>
        <button onclick="testSettingsLoad()">æµ‹è¯•è®¾ç½®åŠ è½½</button>
        <div id="settingsTestResult" class="test-result"></div>
    </div>
    
    <div class="test-section">
        <h2>2. é”™è¯¯å¤„ç†æµ‹è¯•</h2>
        <button onclick="testInvalidSettings()">æµ‹è¯•æ— æ•ˆè®¾ç½®</button>
        <button onclick="testNetworkError()">æµ‹è¯•ç½‘ç»œé”™è¯¯</button>
        <div id="errorTestResult" class="test-result"></div>
    </div>
    
    <div class="test-section">
        <h2>3. ç›‘æ§åŠŸèƒ½æµ‹è¯•</h2>
        <button onclick="testMonitoring()">æµ‹è¯•ç›‘æ§API</button>
        <div id="monitoringTestResult" class="test-result"></div>
    </div>

    <script>
        // æ¨¡æ‹Ÿé€šçŸ¥ç®¡ç†å™¨
        const notificationManager = {
            show: function(message, type) {
                console.log(`[${type.toUpperCase()}] ${message}`);
                const resultDiv = document.getElementById('settingsTestResult');
                const className = type === 'success' ? 'success' : type === 'error' ? 'error' : 'info';
                resultDiv.innerHTML += `<p class="${className}">[${type.toUpperCase()}] ${message}</p>`;
            }
        };

        // ç®€åŒ–çš„APIå®¢æˆ·ç«¯
        class TestAPIClient {
            constructor(baseURL = 'http://localhost:8000') {
                this.baseURL = baseURL;
            }

            async request(url, options = {}) {
                const config = {
                    headers: { 'Content-Type': 'application/json' },
                    ...options
                };

                try {
                    const response = await fetch(`${this.baseURL}${url}`, config);

                    if (!response.ok) {
                        let errorData;
                        try {
                            errorData = await response.json();
                        } catch {
                            errorData = { detail: response.statusText };
                        }
                        const errorMessage = errorData.detail || `HTTP ${response.status}: ${response.statusText}`;
                        throw new Error(errorMessage);
                    }

                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('application/json')) {
                        return await response.json();
                    }
                    return await response.text();

                } catch (error) {
                    console.error('APIè¯·æ±‚å¤±è´¥:', error);
                    const errorMessage = error.message || error.toString() || 'æœªçŸ¥é”™è¯¯';
                    throw new Error(errorMessage);
                }
            }

            async getConfig() {
                const response = await this.request('/config/', { method: 'GET' });
                return response.config || response;
            }

            async validateConfig(section, config) {
                return await this.request('/config/validate', {
                    method: 'POST',
                    body: JSON.stringify({ section, config })
                });
            }

            async updateConfigSection(section, config) {
                return await this.request(`/config/${section}`, {
                    method: 'PUT',
                    body: JSON.stringify(config)
                });
            }

            async getHealth() {
                try {
                    return await this.request('/config/health', { method: 'GET' });
                } catch (error) {
                    return { status: 'unknown', message: 'Health check failed' };
                }
            }
        }

        const apiClient = new TestAPIClient();

        // æ”¶é›†è¡¨å•æ•°æ®
        function collectFormData() {
            return {
                app: {
                    name: document.getElementById('systemName').value,
                    debug: true
                },
                llm: {
                    provider: document.getElementById('llmProvider').value,
                    model: document.getElementById('llmModel').value,
                    temperature: parseFloat(document.getElementById('llmTemperature').value),
                    max_tokens: parseInt(document.getElementById('llmMaxTokens').value)
                },
                embeddings: {
                    provider: document.getElementById('embeddingProvider').value,
                    model: document.getElementById('embeddingModel').value,
                    chunk_size: parseInt(document.getElementById('chunkSize').value),
                    chunk_overlap: parseInt(document.getElementById('chunkOverlap').value)
                }
            };
        }

        // æµ‹è¯•è®¾ç½®ä¿å­˜
        async function testSettingsSave() {
            const resultDiv = document.getElementById('settingsTestResult');
            resultDiv.innerHTML = '<p class="info">æµ‹è¯•è®¾ç½®ä¿å­˜ä¸­...</p>';

            try {
                const settings = collectFormData();
                console.log('æ”¶é›†çš„è®¾ç½®æ•°æ®:', settings);

                // éªŒè¯é…ç½®
                const validationResult = await apiClient.validateConfig('all', settings);
                if (!validationResult.valid) {
                    const errorMessages = [];
                    if (validationResult.errors) {
                        for (const [field, error] of Object.entries(validationResult.errors)) {
                            errorMessages.push(`${field}: ${error}`);
                        }
                    }
                    const errorText = errorMessages.length > 0 ? errorMessages.join('; ') : 'é…ç½®éªŒè¯å¤±è´¥';
                    throw new Error(errorText);
                }

                // ä¿å­˜é…ç½®
                const saveResult = await apiClient.updateConfigSection('all', settings);
                
                notificationManager.show('è®¾ç½®ä¿å­˜æˆåŠŸ', 'success');
                resultDiv.innerHTML += `<p class="success">âœ… ä¿å­˜æˆåŠŸ: ${saveResult.message}</p>`;

            } catch (error) {
                console.error('Failed to save settings:', error);
                const errorMessage = error.message || error.toString() || 'ä¿å­˜è®¾ç½®å¤±è´¥';
                notificationManager.show('ä¿å­˜è®¾ç½®å¤±è´¥: ' + errorMessage, 'error');
                resultDiv.innerHTML += `<p class="error">âŒ ä¿å­˜å¤±è´¥: ${errorMessage}</p>`;
            }
        }

        // æµ‹è¯•è®¾ç½®åŠ è½½
        async function testSettingsLoad() {
            const resultDiv = document.getElementById('settingsTestResult');
            resultDiv.innerHTML += '<p class="info">æµ‹è¯•è®¾ç½®åŠ è½½ä¸­...</p>';

            try {
                const response = await apiClient.getConfig();
                console.log('APIå“åº”:', response);
                
                const settings = response.config || response;
                console.log('è§£æåçš„è®¾ç½®:', settings);

                // å¡«å……è¡¨å•
                if (settings.app?.name) {
                    document.getElementById('systemName').value = settings.app.name;
                }
                if (settings.llm?.provider) {
                    document.getElementById('llmProvider').value = settings.llm.provider;
                }
                if (settings.llm?.model) {
                    document.getElementById('llmModel').value = settings.llm.model;
                }
                if (settings.llm?.temperature !== undefined) {
                    document.getElementById('llmTemperature').value = settings.llm.temperature;
                }
                if (settings.llm?.max_tokens) {
                    document.getElementById('llmMaxTokens').value = settings.llm.max_tokens;
                }

                resultDiv.innerHTML += '<p class="success">âœ… è®¾ç½®åŠ è½½æˆåŠŸï¼Œè¡¨å•å·²æ›´æ–°</p>';

            } catch (error) {
                console.error('Failed to load settings:', error);
                const errorMessage = error.message || error.toString() || 'åŠ è½½è®¾ç½®å¤±è´¥';
                resultDiv.innerHTML += `<p class="error">âŒ åŠ è½½å¤±è´¥: ${errorMessage}</p>`;
            }
        }

        // æµ‹è¯•æ— æ•ˆè®¾ç½®
        async function testInvalidSettings() {
            const resultDiv = document.getElementById('errorTestResult');
            resultDiv.innerHTML = '<p class="info">æµ‹è¯•æ— æ•ˆè®¾ç½®å¤„ç†...</p>';

            const invalidSettings = {
                llm: {
                    provider: "invalid_provider",
                    model: "",
                    temperature: 5.0,
                    max_tokens: -100
                }
            };

            try {
                const validationResult = await apiClient.validateConfig('llm', invalidSettings.llm);
                
                if (!validationResult.valid) {
                    resultDiv.innerHTML += '<p class="success">âœ… é”™è¯¯å¤„ç†æ­£å¸¸ï¼Œæ£€æµ‹åˆ°ä»¥ä¸‹é—®é¢˜:</p>';
                    if (validationResult.errors) {
                        for (const [field, error] of Object.entries(validationResult.errors)) {
                            resultDiv.innerHTML += `<p class="info">  - ${field}: ${error}</p>`;
                        }
                    }
                } else {
                    resultDiv.innerHTML += '<p class="error">âŒ é”™è¯¯å¤„ç†å¤±è´¥ï¼Œåº”è¯¥æ£€æµ‹åˆ°é…ç½®é”™è¯¯</p>';
                }

            } catch (error) {
                resultDiv.innerHTML += `<p class="error">âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}</p>`;
            }
        }

        // æµ‹è¯•ç½‘ç»œé”™è¯¯
        async function testNetworkError() {
            const resultDiv = document.getElementById('errorTestResult');
            resultDiv.innerHTML += '<p class="info">æµ‹è¯•ç½‘ç»œé”™è¯¯å¤„ç†...</p>';

            try {
                // å°è¯•è®¿é—®ä¸å­˜åœ¨çš„ç«¯ç‚¹
                await apiClient.request('/nonexistent-endpoint');
                resultDiv.innerHTML += '<p class="error">âŒ åº”è¯¥äº§ç”Ÿç½‘ç»œé”™è¯¯</p>';
            } catch (error) {
                resultDiv.innerHTML += `<p class="success">âœ… ç½‘ç»œé”™è¯¯å¤„ç†æ­£å¸¸: ${error.message}</p>`;
            }
        }

        // æµ‹è¯•ç›‘æ§åŠŸèƒ½
        async function testMonitoring() {
            const resultDiv = document.getElementById('monitoringTestResult');
            resultDiv.innerHTML = '<p class="info">æµ‹è¯•ç›‘æ§åŠŸèƒ½...</p>';

            try {
                const health = await apiClient.getHealth();
                resultDiv.innerHTML += `<p class="success">âœ… å¥åº·æ£€æŸ¥æˆåŠŸ: ${JSON.stringify(health)}</p>`;
            } catch (error) {
                resultDiv.innerHTML += `<p class="error">âŒ å¥åº·æ£€æŸ¥å¤±è´¥: ${error.message}</p>`;
            }
        }

        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨åŠ è½½è®¾ç½®
        window.onload = function() {
            console.log('ğŸ§ª å‰ç«¯è®¾ç½®åŠŸèƒ½æµ‹è¯•é¡µé¢å·²åŠ è½½');
            testSettingsLoad();
        };
    </script>
</body>
</html>